import StringIO
import platform
from type_mapping import mappings
import time

class Generator:
  def __init__(self, parser):
    self.parser = parser
    self.out = StringIO.StringIO()
    mappings.update(self.parser.type_mappings)

    self.to_go_type_funcs = set()

  def generate(self):
    # package name
    print >>self.out, "// this file is auto-generated by go-gi\n"
    print >>self.out, "package %s\n" % self.parser.package_name
    # pkg-config packages
    if 'gobject-2.0' not in self.parser.pkgconfig_packages:
      self.parser.pkgconfig_packages.append('gobject-2.0')
    print >>self.out, "// #cgo pkg-config: %s" % ' '.join(self.parser.pkgconfig_packages)
    # basic includes
    print >>self.out, "// #include <string.h>"
    print >>self.out, "// #include <glib-object.h>"
    print >>self.out, "// #include <glib/gstdio.h>"
    # platform specific includes
    system = platform.system()
    if system == 'Linux':
      print >>self.out, "// #include <glib-unix.h>"
    # includes
    for include in self.parser.includes:
      print >>self.out, "// #include <%s>" % include
    print >>self.out, "/*"
    # helper codes
    for m in mappings.itervalues():
      if m.help_code:
        print >>self.out, m.help_code
    self.generate_macro_helpers()
    # wrappers
    for func in self.parser.functions_need_helper:
      self.generate_wrapper(func)
    print >>self.out, "*/"
    # cgo
    print >>self.out, 'import "C"'
    # imports
    print >>self.out, 'import ('
    print >>self.out, '\t"unsafe"'
    print >>self.out, '\t"runtime"'
    print >>self.out, ')\n'

    for func in self.parser.functions:
      self.generate_function(func)

    self.generate_enum_symbols()

    self.generate_const_symbols()

    self.generate_to_go_type_func_codes()

    self.generate_record_types()

  def write(self, f):
    output_file = open(f, 'w')
    output_file.write(self.out.getvalue())
    output_file.close()

  def generate_function(self, func):
    # not support yet or has problem
    if func.skip:
      self.out.write('//Skipped %s\n\n' % func.c_name)
      return
    elif func.not_implement:
      self.out.write('//TODO %s\n\n' % func.c_name)
      return

    out = []
    # signature
    if func.is_method:
      out.append('func (self *%s) %s(' % (func.cls, func.go_name))
    else:
      out.append('func %s(' % func.go_name)

    # parameter
    mapping_code = []
    mapped_param_name = {}
    sep = None
    parameters = func.parameters
    if func.is_method: # skip the self param
      parameters = parameters[1:]
    for param in parameters:
      if sep != None: out.append(sep)
      sep = ', '
      mapped_type = param.type.go_type
      if mappings.get(mapped_type, False):
        m = mappings[mapped_type]
        mapped_type = m.mapped_type
        if m.mapping_code_func:
          mapping_code.append(m.mapping_code_func(param))
        mapped_param_name[param.name] = m.mapped_name_func(param)
      out.append('%s %s' % (param.name, mapped_type))
    out.append(') ')

    # return type
    mapped_return_type = func.return_type.go_type
    return_type_mapping = None
    if mappings.get(mapped_return_type, False):
      return_type_mapping = mappings[mapped_return_type]
      mapped_return_type = return_type_mapping.mapped_type
    out.append('%s{\n' % (
      '' if func.no_return else (mapped_return_type + ' '),
      ))
    out.extend(mapping_code)

    # return expression
    return_expression = []
    if return_type_mapping != None:
      if return_type_mapping.to_go_type_func:
        return_expression.append('%s(' % mappings[func.return_type.go_type].to_go_type_func)
        self.to_go_type_funcs.add(func.return_type.go_type)
      elif return_type_mapping.to_go_type_code_head:
        return_expression.append(return_type_mapping.to_go_type_code_head)
    if func.need_helper:
      return_expression.append('C._%s(' % func.c_name)
    else:
      return_expression.append('C.%s(' % func.c_name)

    for i, param in enumerate(func.parameters):
      if i > 0:
        return_expression.append(', ')
      if func.is_method and i == 0: # the self argument
        return_expression.append('(*C.%s)(self)' % func.c_class)
      else: # not a method
        return_expression.append(mapped_param_name.get(param.name, param.name))
    return_expression.append(')')

    if return_type_mapping != None:
      if return_type_mapping.to_go_type_func:
        return_expression.append(')')
      elif return_type_mapping.to_go_type_code_tail:
        return_expression.append(return_type_mapping.to_go_type_code_tail)
    return_expression = ''.join(return_expression)

    # some type mapping use its own return statement
    if return_type_mapping != None and return_type_mapping.return_code_func:
      out.append(return_type_mapping.return_code_func(return_expression))
    else:
      out.append('\t')
      if not func.no_return:
        out.append('return ')
      out.append(return_expression)
      out.append('\n')
    out.append('}\n\n')

    self.out.write(''.join(out))

  def generate_to_go_type_func_codes(self):
    for t in self.to_go_type_funcs:
      self.out.write(mappings[t].to_go_type_func_code)
      self.out.write('\n')

  def generate_wrapper(self, func):
    out = []
    spec = self.parser.func_spec[func.c_name]

    # return type and function name
    out.append('%s %s(' % (
      spec.return_type,
      '_' + func.c_name,
      ))

    # parameters
    for i, param in enumerate(func.parameters):
      if i > 0: out.append(', ')
      out.append(param.type.c_type + ' ' + param.name)
    out.append(') {\n\t')

    # body
    if not func.no_return:
      out.append('return ')
    out.append('%s(' % func.c_name)
    for i, param in enumerate(func.parameters):
      if i > 0: out.append(', ')
      if param.type.c_helper_value_func:
        out.append(param.type.c_helper_value_func(param))
      elif spec.arg_types[i] != param.type.c_type:
        out.append('(%s)(%s)' % (spec.arg_types[i], param.name))
      else:
        out.append(param.name)
    out.append(');\n}\n')
    self.out.write(''.join(out))

  def generate_enum_symbols(self):
    for symbol in self.parser.enum_symbols:
      go_name = symbol
      for prefix in self.parser.prefixes:
        if symbol.startswith(prefix.upper()):
          go_name = symbol[len(prefix) + 1:]
      print >>self.out, "const %s = C.%s" % (go_name, symbol)

  def generate_const_symbols(self):
    for symbol in self.parser.const_symbols:
      go_name = symbol
      for prefix in self.parser.prefixes:
        if symbol.startswith(prefix.upper()):
          go_name = symbol[len(prefix) + 1:]
      print >>self.out, "const %s = C.%s" % (go_name, symbol)

  def generate_macro_helpers(self):
    print >>self.out, "gboolean _true() { return TRUE; }"
    print >>self.out, "gboolean _false() { return FALSE; }"

  def generate_record_types(self):
    for name, c_type in self.parser.construct_records:
      if c_type in self.parser.skip_symbols:
        continue
      print >>self.out, "type %s C.%s" % (name, c_type)
